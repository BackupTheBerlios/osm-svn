/*
 * The contents of this file are subject to the terms
 * of the Common Development and Distribution License
 * (the "License").  You may not use this file except
 * in compliance with the License.
 *
 * You can obtain a copy of the license at
 * glassfish/bootstrap/legal/CDDLv1.0.txt or
 * https://glassfish.dev.java.net/public/CDDLv1.0.html.
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL
 * HEADER in each file and include the License file at
 * glassfish/bootstrap/legal/CDDLv1.0.txt.  If applicable,
 * add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your
 * own identifying information: Portions Copyright [yyyy]
 * [name of copyright owner]
 *
 * Portions Copyright 2006 Sun Microsystems, Inc. All rights reserved.
 * Copyright 2007 Stephen J. McConnell, DPML
 */

package org.apache.jasper.compiler;

import javax.tools.DiagnosticCollector;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.ToolProvider;
import javax.tools.JavaFileManager;
import javax.tools.JavaFileManager.Location;
import javax.tools.JavaFileObject;
import javax.tools.JavaFileObject.Kind;
import javax.tools.SimpleJavaFileObject;
import javax.tools.ForwardingJavaFileManager;
import javax.tools.StandardJavaFileManager;
import javax.tools.StandardLocation;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.Reader;
import java.io.Writer;
import java.io.CharArrayWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;

import java.net.URI;
import java.net.URL;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Arrays;
import java.util.Set;

import org.apache.jasper.JasperException;
import org.apache.jasper.Constants;
import org.apache.jasper.JspCompilationContext;

import net.dpml.transit.Artifact;

/**
 * Invoke Java Compiler per JSR 199, using in-memory storage for both the
 * input Java source and the generated bytecodes.
 *
 * @author Kin-man Chung
 */
public class Jsr199JavaCompiler implements JavaCompiler
{
    private static final List<File> SYSTEM_FILES = getSystemFiles();
    
    private List<File> m_classpath;
    private JspRuntimeContext m_context;
    private ArrayList<BytecodeFile> m_classFiles = new ArrayList<BytecodeFile>(); // generated bytecodes
    private ArrayList<String> m_options = new ArrayList<String>();
    private CharArrayWriter m_charArrayWriter;
    private JspCompilationContext m_compilationContext;
    private String m_javaFilename;
    private String m_javaEncoding;
    private ErrorDispatcher m_errDispatcher;

    public void init(
      JspCompilationContext compilationContext, ErrorDispatcher err, boolean suppressLogging ) 
    {
        m_compilationContext = compilationContext;
        m_errDispatcher = err;
        m_context = compilationContext.getRuntimeContext();
    }

    public void setClassPath( List<File> path ) 
    {
        path.addAll( SYSTEM_FILES );
        m_classpath = path;
    }
    
    public void setExtdirs( String exts ) 
    {
        m_options.add( "-extdirs" );
        m_options.add( exts );
    }

    public void setSourceVM(String sourceVM)
    {
        m_options.add( "-source" );
        m_options.add( sourceVM );
    }

    public void setTargetVM( String targetVM )
    {
        m_options.add( "-target" );
        m_options.add( targetVM );
    }

    public void saveClassFile( String className, String classFileName )
    {
        for( BytecodeFile bytecodeFile: m_classFiles )
        {
            String c = bytecodeFile.getClassName();
            String f = classFileName;
            if( !className.equals(c) ) 
            {
                // Compute inner class file name
                f = f.substring(0, f.lastIndexOf(File.separator)+1) +
                    c.substring(c.lastIndexOf('.')+1) + ".class";
            }
            m_context.saveBytecode(c, f);
        }
    }
    
    public void doJavaFile( boolean keep ) throws JasperException 
    {
        if( !keep ) return;
        try 
        {
            Writer writer = 
              new OutputStreamWriter(
                new FileOutputStream( m_javaFilename ), m_javaEncoding );
            writer.write( m_charArrayWriter.toString() );
            writer.close();
        } 
        catch( UnsupportedEncodingException ex )
        {
            m_errDispatcher.jspError(
              "jsp.error.needAlternateJavaEncoding", m_javaEncoding );
        }
        catch( IOException ex )
        {
            throw new JasperException(ex);
        }
    }

    public void removeJavaFile()
    {
    }
    
    public void setDebug( boolean debug )
    {
        if( debug ) 
        {
            m_options.add( "-g" );
        }
    }

    public Writer getJavaWriter( String javaFilename, String javaEncoding ) 
    {
        m_javaFilename = javaFilename;
        m_javaEncoding = javaEncoding;
        m_charArrayWriter = new CharArrayWriter();
        return m_charArrayWriter;
    }

    public long getClassLastModified() 
    {
        String className = m_compilationContext.getFullClassName();
        return m_context.getBytecodeBirthTime( className );
    }

    public JavacErrorDetail[] compile( 
      String className, Node.Nodes pageNodes ) throws JasperException 
    {
        final String source = m_charArrayWriter.toString();
        javax.tools.JavaCompiler javac = ToolProvider.getSystemJavaCompiler();
        DiagnosticCollector<JavaFileObject> diagnostics =
            new DiagnosticCollector<JavaFileObject>();
        StandardJavaFileManager stdFileManager =
                    javac.getStandardFileManager( diagnostics, null, null );
        String name = className.substring( className.lastIndexOf('.')+1 );
        JavaFileObject[] sourceFiles = 
          {
            new SimpleJavaFileObject(
              URI.create(
                "string:///" 
                + name.replace('.','/') 
                + Kind.SOURCE.extension ),
                Kind.SOURCE ) 
              {
                  public CharSequence getCharContent(boolean ignore) 
                  {
                    return source;
                  }
              }
          };

        try 
        {
            stdFileManager.setLocation(StandardLocation.CLASS_PATH, this.m_classpath);
        } 
        catch (IOException e) 
        {
        }

        javax.tools.JavaCompiler.CompilationTask ct =
          javac.getTask( 
            null, getJavaFileManager( stdFileManager ), diagnostics, m_options, null, 
            Arrays.asList( sourceFiles ) );

        if( ct.call() ) 
        {
            for( BytecodeFile bytecodeFile: m_classFiles ) 
            {
                m_context.setBytecode(
                  bytecodeFile.getClassName(), bytecodeFile.getBytecode() );
            }
            return null;
        }

        // There are compilation errors!
        ArrayList<JavacErrorDetail> problems =
            new ArrayList<JavacErrorDetail>();
        for(Diagnostic dm: diagnostics.getDiagnostics() )
        {
            problems.add( 
              ErrorDispatcher.createJavacError(
                source,
                pageNodes,
                new StringBuffer( dm.getMessage( null ) ),
                (int) dm.getLineNumber() ) );
        }
        return problems.toArray( new JavacErrorDetail[0] );
    }


    private class BytecodeFile extends SimpleJavaFileObject 
    {
        private byte[] bytecode;
        private String className;
        
        BytecodeFile( URI uri, String className ) 
        {
            super( uri, Kind.CLASS );
            this.className = className;
        }

        String getClassName()
        {
            return this.className;
        }

        byte[] getBytecode() 
        {
            return this.bytecode;
        }

        public OutputStream openOutputStream() 
        {
            return new ByteArrayOutputStream() 
            {
                public void close() 
                {
                    bytecode = this.toByteArray();
                }
            };
        }
        
        public InputStream openInputStream() 
        {
            return new ByteArrayInputStream( bytecode );
        }
    }
    
    private JavaFileObject getOutputFile(
      final String className, final URI uri ) 
    {
        BytecodeFile classFile = new BytecodeFile(uri, className);

        // File the class file away, by its package name
        String packageName = className.substring( 0, className.lastIndexOf( "." ) );
        Map<String,ArrayList<Object /*JavaFileObject*/>> packageMap =
            m_context.getPackageMap();
        ArrayList<Object/*JavaFileObject*/> packageFiles = packageMap.get(  packageName);
        if( packageFiles == null )
        {
            packageFiles = new ArrayList<Object/*JavaFileObject*/>();
            packageMap.put( packageName, packageFiles );
        }
        packageFiles.add( classFile );
        m_classFiles.add( classFile );
        return classFile;
    }
    
    private JavaFileManager getJavaFileManager( JavaFileManager fm )
    {
        return new ForwardingJavaFileManager<JavaFileManager>(fm) 
        {
            @Override
            public JavaFileObject getJavaFileForOutput(
              Location location, String className, Kind kind, FileObject sibling )
            {
                return getOutputFile( 
                  className,
                  URI.create( "file:///" + className.replace('.','/') + kind ) );
            }
            
            @Override
            public String inferBinaryName(
              Location location, JavaFileObject file ) 
            {
                if( file instanceof BytecodeFile )
                {
                    return ((BytecodeFile)file).getClassName();
                }
                return super.inferBinaryName( location, file );
            }

            @Override
            @SuppressWarnings( "unchecked" )
            public Iterable<JavaFileObject> list(
              Location location, String packageName, Set<Kind> kinds, boolean recurse )
              throws IOException
            {
                if( location == StandardLocation.CLASS_PATH &&
                  packageName.startsWith(Constants.JSP_PACKAGE_NAME ) ) 
                {
                    Map<String,ArrayList<Object/*JavaFileObject*/>> packageMap =
                        m_context.getPackageMap();
                    ArrayList/*<JavaFileObject>*/ packageFiles
                            = packageMap.get( packageName );
                    if( packageFiles != null )
                    {
                        return packageFiles;
                    }
                }
                Iterable<JavaFileObject> lst =
                  super.list( location, packageName, kinds, recurse );
                return lst;
            }
        };
    }
    
    private static List<File> getSystemFiles()
    {
        List<File> files = new ArrayList<File>();
        addSystemFile( files, "@SERVLET-SPEC@" );
        addSystemFile( files, "@JSP-API-SPEC@" );
        addSystemFile( files, "@JSP-IMPL-SPEC@" );
        return files;
    }
    
    private static void addSystemFile( List<File> list, String artifact )
    {
        try
        {
            URI uri = URI.create( artifact );
            URL url = Artifact.toURL( uri );
            File file = (File) url.getContent( new Class[]{ File.class } );
            if( null != file )
            {
                list.add( file );
            }
            else
            {
                System.err.println( "Missing file: " + artifact );
            }
        }
        catch( Exception e )
        {
            final String error = 
              "Unexpected error while expanding JSP classpath.";
            e.printStackTrace();
        }
    }
}
