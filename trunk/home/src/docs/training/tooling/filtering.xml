<?xml version="1.0" encoding="ISO-8859-1"?>

<document>
  <properties>
    <author email="mcconnell@osm.net">Stephen McConnell</author>
    <title>Component Development Strategies</title>
  </properties>

  <body>

    <section name="Codebase Filtering">

      <subsection name="Tutorial Objective">

        <p>
        The objective of this tutorial is to demonstrate the use of 
        content filters declarations at the level of a project definition.
        </p>

      </subsection>

      <subsection name="Adding filter declarations">
      
        <p>
        A common development requirement concerns the build-time filtering of 
        a codebase involving the replacement of tokens with parameterized values.
        For example, you may want to replace a token such as <tt>@COLOR@</tt>
        with the value (e.g. <tt>RED</tt>, or they token <tt>@NAME@</tt> with the 
        name of the project. In the first case we are dealing with the simple 
        substitution of the token <tt>@COLOR@</tt> with the value <tt>RED</tt>.
        In the second case we are requesting the replacement of the toke <tt>@NAME@</tt>
        with information available from Depot's project definition.
        </p>
        
        <p>
        Both of the above concerns can be automated via declarations within our project 
        definition.  The following XML shows the new project definition content dealing with
        declaration of the respective filters:
        </p>
        
<source>
  &lt;project name="acme-system" basedir="system"&gt;
    &lt;types&gt;
      &lt;type id="jar"/&gt;
    &lt;/types&gt;
    &lt;dependencies&gt;
      &lt;runtime&gt;
        &lt;include key="acme-client"/&gt;
      &lt;/runtime&gt;
      &lt;test&gt;
        &lt;include ref="ant/ant-junit"/&gt;
      &lt;/test&gt;
    &lt;/dependencies&gt;
    <font color="darkred">&lt;filters&gt;
      &lt;filter token="COLOR" value="red"/&gt;
      &lt;feature token="NAME" id="name"/&gt;
    &lt;/filters&gt;</font>
  &lt;/project>
</source>

        <p>
        The first filter is a classic filter that will replace all occurances
        of the pattern <code>@COLOR@</code> in a sources with the value <code>red</code>.
        The second filter is a filter that lets us extract information from the
        project model and apply this as a filter argument.  In this example the feature
        we are requesting is the name of the project.
        </p>
        
      </subsection>
    
      <subsection name="Updates to DefaultWidget.java">

<source>
package acme.impl;

import acme.Widget;

public class DefaultWidget implements Widget
{
    public void process( String color )
    {
        String message = buildMessage( color );
        System.out.println( message );
    }

    public String buildMessage( String color )
    {
        if( null == color )
        {
            <font color="darkred">return "I'm a plain old " + COLOR + " widget named " + NAME + ".";</font>
        }
        else
        {       
            <font color="darkred">return "I'm a " + color + " widget named " + NAME;</font>
        }
    }

    <font color="darkred">private static final String NAME = "@NAME@";
    private static final String COLOR = "@COLOR@";</font>
 
}
</source>

       </subsection>

       <subsection name="Updates to DefaultWidgetTestCase.java">
       
         <p>
         Similar apdates have been made to out testcase to validate default and 
         explicit output values.
         </p>
         
        <p><i>DefaultWidgetTestCase.java</i></p>

<source>
    public void testDefaultMessage() throws Exception
    {
        DefaultWidget widget = new DefaultWidget();
        String result = widget.buildMessage( null );
        <font color="darkred">String expected = "I'm a plain old " + COLOR + " widget named " + NAME + ".";</font>
        assertEquals( "default", expected, result );
        widget.process( null );
    }

    public void testExplicitMessage() throws Exception
    {
        DefaultWidget widget = new DefaultWidget();
        String color = "blue";
        String result = widget.buildMessage( color );
        <font color="darkred">String expected = "I'm a " + color + " widget named " + NAME;</font>
        assertEquals( "explicit", expected, result );
        widget.process( color );
    }

    <font color="darkred">private static final String NAME = "@NAME@";
    private static final String COLOR = "@COLOR@";</font>
</source>

      </subsection>

      <subsection name="Build Output">

        <pre>
test:
  [x:junit] Compiling 1 source file to C:\dev\system\target\test-classes
  [x:junit] executing in local jvm
  [x:junit] Running acme.impl.test.DefaultWidgetTestCase
<font color="darkred">I'm a plain old red widget named acme-system.
I'm a blue widget named acme-system</font>
  [x:junit] Tests run: 3, Failures: 0, Errors: 0, Time elapsed: 0.016 sec
        </pre>

      </subsection>

      <subsection name="Tutorial Summary">

        <p>
        The are a couple of important things covered in this tutorial.  Firstly,
        when Depot prepares project content it constructs a working codebase under
        the <code>${basedir}/target/build</code> directory.  This codebase is the 
        result of applying any filters declared within the <code>project</code> defintion.  
        Secondly, the example demonstrates how you can easily reference features of 
        the current project model (or any other project or resource included within 
        the library scope).  A full descriptrion of available project features is detailed
        in the <a href="http://www.dpml.net/depot/library/filters/feature.html">
        library/feature/filter</a> specification.
        </p>
        
      </subsection>

      <subsection name="Next Topic ...">
      
        <p>
        All of the examples we have looked at so far have been based exclusively on 
        information available in the project definition.  However, in practice you will
        encounter siturations where the general build strategy provided by Depot does 
        not provide everythihg you need.  The <a href="customization.html">following tutorial demonstrates how you
        can customize the default build strategy</a>.
        </p>

      </subsection>
      
    </section>

  </body>
  
</document>

