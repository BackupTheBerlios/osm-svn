<?xml version="1.0" encoding="ISO-8859-1"?>

<document>
  <properties>
    <author email="mcconnell@osm.net">Stephen McConnell</author>
    <title>Resource Management</title>
  </properties>

  <body>

    <section name="Transit Part Management">

      <subsection name="Tutorial Objective">

        <p>
        The aim of this tutorial is to establish a good understanding 
        of the term "part" and how part management can help you 
        to build flexible and adaptive runtime system by leaveraging
        Transit's cassloader construction services.
        </p>

      </subsection>

      <subsection name="Definition of a Part">

        <p>
        A <code>part</code> is an resource type that is used to describe 
        a classloader chain.  The part resource is an XML file that 
        declares the contents of an PUBLIC classloader, PROTECTED classloader, 
        and an PRIVATE implementation classloader. Each classloader definition is 
        expressed as a series of jar artifact uris.  Transit provides 
        support for the construction of classloader chains based on the 
        information contained within the part definition.  A chain is 
        constructed by creating an PUBLIC classloader as child of a supplied 
        parent classloader, a PROTECTED classloader as a child of the PUBLIC classloader, 
        and a PRIVATE implementation classloader as a child of the PROTECTED classloader.
        </p>

        <p>
        In additon to classloader chain information, a part resource can 
        include the declaration of a deployment strategy.  The Transit system provides support
        for 'plugin' strategies that enable declaration of a main class or resource.  The 
        combination of classloader chain with a deployment strategy combines 
        to provide a framework for plugable sub-systems deployment.
        </p>

      </subsection>

      <subsection name="A sample part resource">

        <p>
        The following file is an example of a part resource.  The 
        example is a development version of the part resource used to mount the 
        runtime controller that executes within the Metro component management 
        platform.
        </p>

        <source><![CDATA[<?xml version="1.0"?>

<part xmlns="artifact:xsd:dpml/lang/dpml-part#1.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

  <info title="Untitled">
    <description></description>
  </info>

  <strategy xsi:type="plugin" class="net.dpml.metro.runtime.CompositionController"/>

  <classpath>
    <public>
      <uri>artifact:jar:dpml/util/dpml-logging-api#1.0.0-RC4</uri>
    </public>
    <protected>
      <uri>artifact:jar:dpml/metro/dpml-state-api#1.0.0-RC4</uri>
      <uri>artifact:jar:dpml/util/dpml-job-api#1.0.0-RC4</uri>
      <uri>artifact:jar:dpml/transit/dpml-transit-main#1.0.0-RC4</uri>
      <uri>artifact:jar:dpml/metro/dpml-metro-component#1.0.0-RC4</uri>
      <uri>artifact:jar:dpml/util/dpml-parameters-api#1.0.0-RC4</uri>
      <uri>artifact:jar:dpml/util/dpml-configuration-api#1.0.0-RC4</uri>
      <uri>artifact:jar:dpml/metro/dpml-metro-model#1.0.0-RC4</uri>
    </protected>
    <private>
      <uri>artifact:jar:dpml/util/dpml-parameters-impl#1.0.0-RC4</uri>
      <uri>artifact:jar:dpml/util/dpml-configuration-impl#1.0.0-RC4</uri>
      <uri>artifact:jar:dpml/util/dpml-job-impl#1.0.0-RC4</uri>
      <uri>artifact:jar:dpml/metro/dpml-state-impl#1.0.0-RC4</uri>
      <uri>artifact:jar:dpml/depot/dpml-library#1.0.0-RC4</uri>
      <uri>artifact:jar:dpml/metro/dpml-metro-builder#1.0.0-RC4</uri>
      <uri>artifact:jar:dpml/metro/dpml-metro-runtime#1.0.0-RC4</uri>
    </private>
  </classpath>

</part>
]]></source>

      </subsection>

      <subsection name="Part Creation">

        <p>
        In practice the creation and maintenance of plugin information is highly 
        error prone due to overall complexity of dependency management. This was one
        of the driving factors in the development of the Depot build system.  Depot 
        was developed from the ground up to provided full transitive 
        dependency management across build, runtime and test scopes. Using the 
        Depot project model the job of creating a plugin definition is reduced down 
        to type production declaration within a project definition.
        </p>

<pre>
  &lt;project name="dpml-metro-runtime" basedir="runtime"&gt;
    &lt;types&gt;
      &lt;type id="jar"/&gt;
      <font color="darkred">&lt;part:plugin alias="true" class="net.dpml.metro.runtime.CompositionController"/&gt;</font>
    &lt;/types&gt;
    &lt;dependencies&gt;
      &lt;include ref="dpml/util/dpml-logging-api" tag="public"/&gt;
      &lt;include ref="dpml/util/dpml-parameters-impl"/&gt;
      &lt;include ref="dpml/util/dpml-configuration-impl"/&gt;
      &lt;include ref="dpml/util/dpml-job-impl"/&gt;
      &lt;include key="dpml-metro-component" tag="protected"/&gt;
      &lt;include key="dpml-metro-model" tag="protected"/&gt;
      &lt;include key="dpml-state-impl"/&gt;
      &lt;include key="dpml-metro-builder" tag="protected"/&gt;
    &lt;/dependencies&gt;
    &lt;dependencies scope="test"&gt;
      &lt;include ref="ant/ant-junit"/&gt;
    &lt;/dependencies&gt;
  &lt;/project&gt;
</pre>

      </subsection>

      <subsection name="Plugin Loading">

        <p>
        Transit provides a number of plugin related services including loading of 
        plugin descriptor, creation of a plugin classloader chain, plugin class 
        establishment, plugin instance establishment, and generic object 
        instantiation utility function.  Collectively these methods make the 
        process of sub-systems creation a painless development process.  
        </p>

        <p>
        The following example demonstrates the creation of a plugin sub-system 
        using Transit.
        </p>

        <source>
  URI uri = new URI( "@METRO-RUNTIME-URI@" );
  Part part = Part.load( uri );
  Logger logger = getLogger();
  m_handler = (ContentHandler) part.instantiate( new Object[]{ logger } );
        </source>

        <p>
        The above code is typical in that it covers the following functions:
        </p>

        <ol>
          <li>Establish the classloader that will serve as the anchor for the classloader chain.</li>
          <li>Create an artifact URI referencing a "plugin" resource.</li>
          <li>Construct any objects that should be supplied as constructor arguments.</li>
          <li>Load the part definition.</li>
          <li>Request part instantiation using supplied constructor arguments.</li>
        </ol>

        <p>
        Within production applications you would typically see a reasonable amount of error 
        handling code wrapping the above code framgment.  The error handling code would typically 
        handle validation of the plugin either prior to instantiation or part of a try catch block, 
        type checking, etc.
        </p>

      </subsection>

    </section>

  </body>

</document>

