<?xml version="1.0" encoding="ISO-8859-1"?>

<document>
  <properties>
    <author email="mcconnell@osm.net">Stephen McConnell</author>
    <title>Resource Management</title>
  </properties>

  <body>

    <section name="Transit Plugin Management">

      <subsection name="Tutorial Objective">

        <p>
        The aim of this tutorial is to establish a good understanding 
        of the term "plugin" and how plugin management can help you 
        to build flexible and adaptive runtime system by leaveraging
        Transit's cassloader construction services.
        </p>

      </subsection>

      <subsection name="Definition of a Plugin">

        <p>
        A <code>plugin</code> is an resource type that is used to describe 
        a classloader chain.  The plugin resource is a property file that 
        declares the contents of an PUBLIC classloader, PROTECTED classloader, 
        and an PRIVATE implementation classloader. Each classloader defintion is 
        expressed as a series of jar artifact uris.  Transit provides 
        support for the construction of classloader chains based on the 
        information contained within the plugin resource.  A chain is 
        constructed by creating an PUBLIC classloader as child of a supplied 
        parent classloader, an PROTECTED classloader as a child of the PUBLIC classloader, 
        and a PRIVATE implementation classloader as a child of the PROTECTED classloader.
        </p>

        <p>
        In additon to classloader chain information, a plugin resource can 
        include the declaration of a main class or resource.  The combination 
        of classloader chain with a loadable target (class or resource) combines 
        to provide a framework for plugable sub-systems deployment.
        </p>

      </subsection>

      <subsection name="A sample plugin resource">

        <p>
        The following property file is an example of a plugin resource.  The 
        example is a development version of the plugin resource used to mount the 
        runtime controller that executes within the Metro component management 
        platform.
        </p>

        <source>

#
# Specification classifier.
#
dpml.plugin.meta.namespace = net.dpml
dpml.plugin.meta.version = 1.0

#
# Artifact descriptor.
#
dpml.artifact.group = dpml/metro
dpml.artifact.name = dpml-metro-runtime
dpml.artifact.version = 20051228
dpml.artifact.signature = 20051227.175001

#
# Type.
#
dpml.plugin.class = net.dpml.metro.runtime.CompositionController

#
# Public.
#
dpml.artifact.dependency.api.0 = artifact:jar:dpml/util/dpml-logging-api#20051228

#
# Protected.
#
dpml.artifact.dependency.spi.0 = artifact:jar:dpml/metro/dpml-state-api#20051228
dpml.artifact.dependency.spi.1 = artifact:jar:dpml/transit/dpml-transit-main#20051228
dpml.artifact.dependency.spi.2 = artifact:jar:dpml/metro/dpml-part-api#20051228
dpml.artifact.dependency.spi.3 = artifact:jar:dpml/util/dpml-parameters-api#20051228
dpml.artifact.dependency.spi.4 = artifact:jar:dpml/util/dpml-configuration-api#20051228
dpml.artifact.dependency.spi.5 = artifact:jar:dpml/metro/dpml-metro-model#20051228

#
# Private.
#
dpml.artifact.dependency.0 = artifact:jar:dpml/util/dpml-parameters-impl#20051228
dpml.artifact.dependency.1 = artifact:jar:dpml/util/dpml-configuration-impl#20051228
dpml.artifact.dependency.2 = artifact:jar:dpml/metro/dpml-state-impl#20051228
dpml.artifact.dependency.3 = artifact:jar:dpml/metro/dpml-metro-runtime#20051228

#
# EOF.
#
        </source>

      </subsection>

      <subsection name="Plugin Creation">

        <p>
        In practice the creation and maintenance of plugin information is highly 
        error prone due to overall complexity of dependency management. This was one
        of the driving factors in the development of the Depot build system.  Depot 
        was developed from the ground up to provided full transitive 
        dependency management across build, runtime and test scopes. Using the 
        Depot project model the job of creating a 
        plugin definition is reduced down to type production declaration within a 
        project definition.
        </p>

<pre>
  &lt;project name="dpml-metro-runtime" basedir="runtime"&gt;
    &lt;types&gt;
      &lt;type id="jar"/&gt;
      <font color="darkred">&lt;type id="plugin"&gt;
        &lt;property name="project.plugin.class" 
           value="net.dpml.metro.runtime.CompositionController"/&gt;
      &lt;/type&gt;</font>
    &lt;/types&gt;
    &lt;dependencies&gt;
      &lt;include ref="dpml/util/dpml-logging-api" tag="public"/&gt;
      &lt;include ref="dpml/util/dpml-parameters-impl"/&gt;
      &lt;include ref="dpml/util/dpml-configuration-impl"/&gt;
      &lt;include key="dpml-state-impl"/&gt;
      &lt;include key="dpml-part-api" tag="protected"/&gt;
      &lt;include key="dpml-metro-model" tag="protected"/&gt;
    &lt;/dependencies&gt;
    &lt;dependencies scope="test"&gt;
      &lt;include ref="ant/ant-junit"/&gt;
    &lt;/dependencies&gt;
  &lt;/project&gt;
</pre>

      </subsection>

      <subsection name="Plugin Loading">

        <p>
        Transit provides a number of plugin related services including loading of 
        plugin descriptor, creation of a plugin classloader chain, plugin class 
        establishment, plugin instance establishment, and generic object 
        instantiation utility function.  Collectively these methods make the 
        process of sub-systems creation a painless development process.  
        </p>

        <p>
        The following example demonstrates the creation of a plugin sub-system 
        using Transit.
        </p>

        <source>
  Logger logger = getLogger();
  ClassLoader classloader = Thread.currentThread().getContextClassLoader();
  URI uri = new URI( "@METRO-RUNTIME-URI@" );
  Repository repository = Transit.getInstance().getRepository();
  m_handler = (ContentHandler) repository.getPlugin( classloader, uri, new Object[]{ logger } );
        </source>

        <p>
        The above code is typical in that it covers the following functions:
        </p>

        <ol>
          <li>Establish the classloader that will serve as the anchor for the classloader chain.</li>
          <li>Create an artifact URI referencing a "plugin" resource.</li>
          <li>Construct any objects that should be supplied as constructor arguments.</li>
          <li>Get the reference to the Transit plugin service.</li>
          <li>Request plugin creation using anchor classloader, the uri, and the constructor arguments.</li>
        </ol>

        <p>
        Within production applications you would typically see a reasonable amount of error 
        handling code wrapping the above code framgment.  The error handling code would typically 
        handle validation of the plugin either prior to instantiation or part of a try catch block, 
        type checking, etc.  For additional details see the net.dpml.transit.Repository 
        interface documentation.
        </p>

      </subsection>

    </section>

  </body>

</document>

