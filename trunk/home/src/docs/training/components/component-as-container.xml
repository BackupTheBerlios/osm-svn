<?xml version="1.0" encoding="ISO-8859-1"?>

<document>
  <properties>
    <author email="mcconnell@osm.net">Stephen McConnell</author>
    <title>Component in a Context</title>
  </properties>

  <body>

    <section name="When the Component is a Container">

      <p>
      The previouse example demonstrated the usage of the parts inner 
      interface as a convinient mechanism through which a component implementation
      can access resources that are for all practical purposes a part of the 
      component.  However - when a component is acting in the role of a container
      we frequently require greater control over internal parts - after all, if our
      component is really a container then it has the potential to manage itself.
      This option of managing internal parts is the subject of this tutorial.
      </p>

      <subsection name="Component Example">

        <p>
        <tt>tutorial/components/006</tt>:
        </p>

        <table>
          <tr>
            <td><a href="006/Demo.java.html">Demo.java</a></td>
            <td>The demo class with an updated to reference the <tt>PartsManager</tt> 
            interface in preference to a locally defined <tt>Parts</tt> interface.</td>
          </tr>
        </table>
        
        <p>
        The deployment solution remains unchanged - however, readers should note that
        the usage of the <tt>PartsManager</tt> interface is our first occurance of a 
        Metro container API dependency.
        </p>
        
        <p><i>The revised <a href="006/Demo.java.html">Demo.java</a> implementation.</i></p>
        
<pre>
package org.acme;

import java.awt.Color;
import java.util.logging.Logger;
import java.util.logging.Level;

<font color="darkred">import net.dpml.component.Component;
import net.dpml.component.Provider;
import net.dpml.metro.PartsManager;</font>

public class Demo
{
    public Demo( final Logger logger, final PartsManager parts )
    {
        if( logger.isLoggable( Level.INFO ) )
        {
            <font color="darkred">Component component = parts.getComponentHandler( "widget" );
            Provider provider = component.getProvider();
            Widget widget = (Widget) provider.getValue( true );</font>
            Color color = widget.getColor();
            logger.info( "located the color " + color );
        }
    }
}
</pre>

      </subsection>
      
      <subsection name="Summary">

        <p>
        By using the <tt><a href="@API-HOST@/dpml/@DPML-VERSION@/net/dpml/metro/PartsManager.html">
        PartsManager</a></tt> interface, our component can 
        take complete control over the managment of the components that are included 
        within itself.  It can access the managment model of internal parts, control
        part state and deployment status, in effect - the enclosing component is the 
        master of all things within itself.
        </p>
        
        <p>
        Usage of a inner <tt>Parts</tt> interface may be combined with <tt>PartsManager</tt> 
        interface via extension.  For example - the following interface defintion combines
        the managment advanntages provided by <tt>PartsManager</tt> with the type-safe 
        convinience of a locally defined <tt>Parts</tt> interface:
        </p>
        
<pre>
public class Demo
{
    <font color="darkred">public interface Parts extends PartsManager
    {
        Widget getWidget();
    }</font>
    
    public Demo( final Logger logger, final Parts parts )
    {
        ...
    }
}
</pre>

        <p>
        Our <a href="context-lookup.html">next tutorial</a> examines the use of 
        context service lookup between nested components.
        </p>

      </subsection>
      
    </section>

  </body>

</document>

