<?xml version="1.0" encoding="ISO-8859-1"?>

<document>

  <properties>
    <author email="mcconnell@osm.net">Stephen McConnell</author>
    <title>Context Driven Development</title>
  </properties>

  <body>

    <section name="Working with Context">

      <p>
      The purpose of this tutorial is to introduce the context model and the 
      contract this represents between a container and a component.
      </p>

      <subsection name="Operation Requirements">

        <p>
        Components are typically established and deployed dynamically
        by a controlling system.  To do this the controlling system 
        needs to know about the operational requirements of the 
        component and delivery mechanism assumed by a component. Within 
        the Metro component model both the declaration of requirement and 
        the delivery mechanism are described using a <tt>Context</tt> inner 
        interface within a component implementation class.  
        </p>
        <p>
        For example ...
        </p>

<pre>
public class Example
{
    <font color="darkred">public interface Context
    {
        String getName();
        int getHeight();
        int getWidth();
        Color getColor( Color color );
    }</font>

    public Example( Context context )
    {
        String name = context.getName();
        Color color = context.getColor( Color.RED );
        ...
    }

    ...
}
</pre>

        <p>
        The Context interface is a component driven contract.  The information 
        disclosed in the interface can be analysed by a container.  The container
        is any system acting in the role of component lifecycle manager (which
        could be a dedicated container solution or even a testcase).
        </p>

      </subsection>

      <subsection name="Simple Context Example">

        <p>
        <tt>tutorial/components/101</tt>:
        </p>

        <table>
          <tr>
            <td>Filename</td><td>Description</td>
          </tr>
          <tr>
            <td><a href="101/SimpleWidget.java.html">SimpleWidget</a></td>
            <td>A minimal component implementation that contains an inner Context interface
                definition.</td>
          </tr>
          <tr>
            <td><a href="101/ExecutionTestCase.java.html">ExecutionTestCase</a></td>
            <td>Testcase the validates component deployment.</td>
          </tr>
          <tr>
            <td><a href="101/ManagementTestCase.java.html">ManagementTestCase</a></td>
            <td>Testcase demonstrating runtime manipulation of component context values.</td>
          </tr>
        </table>

        <p>
        Looking closer at the Context interface declared by the SimpleWidget component we have 
        the following inner class declaration:
        </p>

<source>public interface Context
{
    String getActivity();
    String getOwner();
    String getTarget();
}
</source>

        <p>
          This contract is stating that an implementation of the Context interface 
          <strong>must</strong> supply a value for the features <code>activity</code>, 
          <code>owner</code>, and <code>target</code>, each of which (in this example) 
          are instances of <code>java.lang.String</code>.
        </p>

        <p>
          <i>
          Noteable points:
          </i>
        </p>

        <ol>
          <li>no exceptions in method declaration</li>
          <li>dependency type is the method return type (and any return type 
            including primatives and custom interfaces and classes are valid 
            return type)</li>
          <li>dependency key is based on the method name applying the bean 
            pattern get[key]</li>
          <li>defalt values may be declared as a single method argument</li>
          <li>if a default value is declared it must be assignable to the method return type</li>
        </ol>

      </subsection>

      <subsection name="Extract from the build file">

        <p><i>The following lines are example of the creation of a component type defintion
           and deployment solution (taken from the components/101 build.xml file):</i></p>

         <pre><![CDATA[  <target name="build" depends="standard.build">
    <c:type class="org.acme.tutorial.SimpleWidget" threadsafe="true"/>
    <c:component type="net.osm.tutorial.SimpleWidget" name="demo">
      <context>
        <entry key="activity" value="Painting"/>
        <entry key="owner" value="$${user.name}"/>
        <entry key="target" value="house"/>
      </context>
    </c:component>
  </target>
]]></pre>

         <p>And the relevant build output ..</p>
<pre>
[m:type] creating [org.acme.tutorial.SimpleWidget]
[m:component] creating [widget] using [org.acme.tutorial.SimpleWidget]</pre>

         <p>
         The <tt>type</tt> task uses introspection to evaluation the component 
         class during which it constructs an internal model of the components 
         assumptions and capabilities.  This information is supsequently used 
         to construct a default deployment scenario using the <tt>component</tt>
         task.
         </p>

      </subsection>

      <subsection name="Testing the component">

        <p>
        During execution of the testcases we see the result of logging the 
        widget message reflecting configuration and runtime information.  In
        the <a href="101/ExecutionTestCase.java.html">ExecutionTestCase</a> 
        the output is simnply the result of apply defualt values establied during 
        the creation of the component deployment profile. In the 
        <a href="101/ManagementTestCase.java.html">ManagementTestCase</a> the 
        generated messsage has changed based on the testcase manipulation of the 
        component's remotely accessible context model. 
        </p>

<pre>
test:
    [javac] Compiling 3 source files to C:\101\target\classes\test
    [junit] executing in local jvm
    [junit] Running org.acme.tutorial.test.DefaultsTestCase
    [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.406 sec
    [junit] Running org.acme.tutorial.test.ExecutionTestCase
[1592 ] [INFO   ] (widget): Painting mcconnell's house blue.
    [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.375 sec
    [junit] Running org.acme.tutorial.test.ManagementTestCase
[1592 ] [INFO   ] (widget): Painting mcconnell's car red.
    [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.36 sec
</pre>

      </subsection>

      <subsection name="Summary ...">

        <p>
        The container will make best efforts to assemble a viable deployment 
        scenario.  If that scenario cannot be established then your component will 
        not be deployed.  During deployment the container will evaluate all runtime 
        requirements declaring with a #Context innner interface, build an context
        implementation fullfilling the contract (and any other regognized contructor
        arguments) and deploy the component taking into account lifecyle and lifestyle
        (but more of these subject later in the tutorial).
        <!--
        The <a href="execution.html">next tutorial</a> we will run up this 
        component in a test case demonstrating contain emabedding, component execution, 
        default context validation, and runtime context management.
        -->
        </p>

      </subsection>

    </section>

  </body>
</document>



