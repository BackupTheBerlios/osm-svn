<?xml version="1.0" encoding="ISO-8859-1"?>

<document>
  <properties>
    <author email="mcconnell@osm.net">Stephen McConnell</author>
    <title>Component Parts</title>
  </properties>

  <body>

    <section name="Logger">

      <subsection name="Tutorial Objective">

        <p>
        The objective of this tutorial is to assert the fact that logging
        is not big issue.  The Metro runtime recognizes two logging classes - the
        first is the defacto standard <tt>java.util.logging.Logger</tt>.  The 
        second is a pragmatic wrapper that presents a logging channel as an 
        immutable service exposing a small number of management independent  
        logging functions.
        </p>
        
      </subsection>

      <subsection name="Recognized Logger Classes">
      
        <p>
        The following table summarises the two logging classes that are 
        recognized by the Metro runtime platform as valid constructor arguments. 
        </p>
        
        <table>
          <tr>
            <td>java.util.loging.Logger</td>
            <td>
            This is the defacto logging implementation included within 
            the Java Runtime.  Generally speaking the <tt>Logger</tt> class
            provides everything you need although it leaves a lot of room 
            for consolidation (hence the introduction of an alternative).
            </td>
          </tr>
          <tr>
            <td>net.dpml.logging.Logger</td>
            <td>
            This is an interface that exposes a small set of query and execution 
            operation concerning logging. The <tt>Logger</tt> class provides 
            support for priority evaluation (logger.isXxxxEnabled) and priority-based 
            log message generation (logger.info( ... ), etc.).  The standard logging priorities
            supported by the interface include <tt>debug</tt>, <tt>info</tt>, 
            <tt>warning</tt>, and <tt>error</tt>. In adfdition to query and actionable
            operations, the Logger interface declares the logger.getChildLogger( &lt;name&gt; )
            method, enabling access to a logging channel that is a subsidiary of the assigned
            logging channel.
            </td>
          </tr>
        </table>
        
      </subsection>

      <subsection name="The DPML Logger">
      
        <p>
        The DPML <tt>Logger</tt> interface exposes a set of operations that meet 
        the requirements of a component implementation.  More specifically - the
        DPML <tt>Logger</tt> interface does not expose operations dealing with channel
        management.  A typical usage scenario is demonstrated in the following code 
        fragment:
        </p>
        
        <source>
import net.dpml.logging.Logger;
        
public class Demo
{
    public Demo( <font color="darkred">final Logger logger</font> )
    {
        ...
        
        if( <font color="darkred">logger.isDebugEnabled()</font> )
        {
            <font color="darkred">logger.debug(</font> "Handling object instantiation." <font color="darkred">)</font>;
        }
        
        ...
        
        if( <font color="darkred">logger.isInfoEnabled()</font> )
        {
            <font color="darkred">logger.info(</font> "Hello." <font color="darkred">)</font>;
        }
        
        ...
    }
    
    ...
}
        </source>
        
      <subsection name="Channel Management">
      
        <p>
        Irrespect of the logging constructor type you choose, in both cases the underlying
        log channel management is based on the management utilities provided withing the 
        <tt>java.util.logging</tt> package.  In particular, this means that the logging 
        configuration (channel priority, channel targets, etc. may be changed at runtime 
        by an independent managment application.
        </p>

      </subsection>

    </section>

  </body>
</document>

