<?xml version="1.0" encoding="ISO-8859-1"?>

<document>

  <properties>
    <author email="mcconnell@osm.net">Stephen McConnell</author>
    <title>Context Driven Development</title>
  </properties>

  <body>

    <section name="Working with Context">

      <subsection name="Operation Requirements">

        <p>
        Components are typically established and deployed dynamically
        by a controlling system.  To do this the controlling system 
        needs to know about the operational requirements of the 
        component and delivery mechanism.
        </p>

        <p>
        Within the Metro component model both the declaration of 
        requirement and the delivery mechanism are described using an 
        inner interface within the component class.
        </p>

        <p>
        Consider the following component implementation:
        </p>

<source>
public class SimpleWidget implements Widget
{
    <font color="darkred">public interface Context
    {
        String getActivity();
        String getOwner();
        String getTarget();
    }</font>

    private final Logger m_logger;
    private final Context m_context;

    public SimpleWidget( Logger logger, Context context  )
    {
        m_logger = logger;
        m_context = context;
    }

    //------------------------------------------------------------------
    // Widget
    //------------------------------------------------------------------

   /**
    * Implementation of the widget service contract.
    */
    public void process( String color )
    {
        String message = buildMessage( color );
        m_logger.info( message );
    }

   /**
    * Utility operation to construct a message.
    * @param color the colour to use
    */
    public String buildMessage( String color )
    {
        String owner = m_context.getOwner();
        String activity = m_context.getActivity();
        String target = m_context.getTarget();

        return activity + " " + owner + "'s " + target + " " + color + ".";
    }
}
</source>

        <p>
          Generally speaking its a regular Java object.  No framework imports, 
          no tag markup, just plain old java.  However - just a a classic java 
          application is supplied with an array of string arguments via a main 
          method - a component is supplied with arguments via its constructor.
          In the above example its the container that is supplying the logger
          and a Context implementation.
        </p>

      </subsection>

      <subsection name="Constructor parameters">

        <p>
          In our example there are two constructor parameters - an instance of 
          <code>java.util.logging.Logger</code> and an instance of <code>Content</code>.
          Both arguments come from the container that this component is running within.
          The Logger argument is just one one of several constructor arguments that the 
          container provides out of the box.  Generally speaking you can add constructor 
          arguments like <code>java.util.logging.Logger</code> and a number of convinient 
          utility types.  How these arguments get constructed is not a concern of the 
          component in question (or for this tutorial) - but what is a concern is that 
          all constructor arguments are valid and properly prepared.  This is of particular
          importance when we consider the Context argument as the interface is declared by 
          the component and the implementation is constructed dynamically by the container.
        </p>

        <p>
        Under the current implementation you can declare any of the following constructor
        parameter types:
        </p>

        <ul>
          <li>#Context (inner interface declaring operation requirements)</li>
          <li>#Parts (inner interface to internal parts of the component)</li>
          <li>java.util.logging.Logger</li>
          <li>net.dpml.logging.Logger (simplified wrapper to a Java Logger)</li>
          <li>net.dpml.parameters.Parameters</li>
          <li>net.dpml.configuration.Configuration</li>
        </ul>

      </subsection>

      <subsection name="And semantics too!">

         <p>
         But what about implementation semantics?  
         Is this component thread-safe.  What are the static charateristics of 
         this component - what are the logging assumptions, the dependencies implied 
         by the Context argument, configuration and parameter presumations, what 
         about garbage collection?
         </p>

         <p>
         We build information about static semantics using an ant task named "type".  This 
         tasks grills the component class and creates a serialized object with
         a bunch of information about the component implementation which it stores 
         along side the component class.
         </p>

         <p>
         Here's an example of static data collection using an Ant build file:
         </p>

         <pre><![CDATA[  <target name="build" depends="standard.build">
    <c:type class="net.osm.tutorial.SimpleWidget" threadsafe="true"/>
  </target>]]></pre>

         <p>And the build output from the above is ..
         </p>
         
         <pre>  [c:type] creating [net.osm.tutorial.SimpleWidget] </pre>

         <p>But more imprtant is the output .. take a look in your <code>
            ${basedir}/target/classes</code> directory and you will find 
            an additional resource named <code>[classname].type</code>. This 
            file contains a serialized representation of you component.  The
            information it contains will be used by built-time and run-time
            systems during the prepration and execution phases.
         </p>
         
      </subsection>

      <subsection name="Supply versus Demand">

        <p>
          The Context interface is about component driven demand.  A component can 
          declare an inner Context interface.  The information disclosed in the interface
          will be analysed by the container and appropriate solutions will be established
          using a solution scenario provided by someone in control.  The solution 
          scenario is the supply side of the equation.  Fortunately we provide a bunch of tools 
          to make solution creation nothing less than a walk-in-the-park - but first of all
          lets' take a look at the demand proposition:
        </p>

<source> 
public class SimpleWidget implements Widget
{
    public interface Context
    {
        String getActivity();
        String getOwner();
        String getTarget();
    }

    ...
}
</source>

        <p>
          This contract is stating that an implementation of the Context interface 
          (which is a component assertion but a container concern) <strong>must</strong> supply a value for 
          the features <code>activity</code>, <code>owner</code>, and <code>target</code>, 
          each of which happens to be a <code>java.lang.String</code> type.
        </p>

        <p><i>
          Important point here is the implicit semantics:
        </i></p>

        <ol>
          <li>no exceptions in method declaration</li>
          <li>dependency type is the method return type (and any return type including primatives and custom interfaces are valid return type)</li>
          <li>dependency key is based on the bean pattern get[key] principal</li>
          <li>optional defalt values may be passed as a operation argument - for example:<source>int getHeight( int defaultHeight );</source></li>
        </ol>

        <p><i>Here's an example of the creation of a solution using another Ant task:</i></p>

         <pre><![CDATA[  <c:component type="net.osm.tutorial.SimpleWidget" name="demo">
    <context>
      <entry key="activity" value="Painting"/>
      <entry key="owner" value="$${user.name}"/>
      <entry key="target" value="house"/>
    </context>
  </c:component>]]></pre>
 
         <p>And the Ant output ..</p>
<pre>
[c:component] creating [demo] using [net.osm.tutorial.SimpleWidget]
[c:component] saving part to: artifact:part:osm/tutorial/osm-application-101#SNAPSHOT
[c:component] Created report in C:\dev\applications\101\target\reports\parts\demo.xml</pre>

      </subsection>

      <subsection name="Summary ...">

        <p>
          The container will make best efforts to assemble a viable deployment 
          scenario.  If that scenario cannot be established then your component will 
          not be deployed.
        </p>

        <p>
          In the <a href="testcase.html">next tutorial</a> we will run up this 
          component in a test case.
        </p>

      </subsection>

    </section>

  </body>
</document>

