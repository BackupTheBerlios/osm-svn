<?xml version="1.0" encoding="ISO-8859-1"?>

<document>
  <properties>
    <author email="mcconnell@osm.net">Stephen McConnell</author>
    <title>Resource Management</title>
  </properties>

  <body>

    <section name="Transit Content Handlers">

      <subsection name="Tutorial Objective">

        <p>
        The Transit system provides a complete management API that allows
        runtime modification of the differenent aspects of the Transit runtime.
        This tutorial aims to provide a brief introduction to advanced Transit
        system management, specific details concerning dynamic assignment of 
        content handlers, and some working examples. 
        </p>

      </subsection>

      <subsection name="What is a Content Handler?">

        <p>
        A ContentHandler is the name of a class used by the JVMs URL 
        object model to handle streamable content based on mime type 
        mappings.  You can declare new content handlers in much the same way 
        you declare new protocol handlers (using system properties and adding
        classes to the system classloader).  However - this approach assumes 
        that a system can be brought down in order to add, update, or remove 
        a new content handler (which is ok for testcases). Transit provide a 
        more powerful and fleixble solution to content handling by intercepting 
        content requests at the level of the Transit artifact protocol handler.
        </p>

      </subsection>

      <subsection name="Setting up a managed Transit instance">

        <p>
        All of the tutorial content present so far has demonstrated the operation
        of Transit under it's default mode of operation.  Behind the scenes each time
        you startup a new JVM containing Transit, a TransitModel is established based 
        on information supplied by a TransitStore.  The TransitStore is an interface to 
        a persistent storage system that is backed by the java.util.Preferences API
        (which in turn is storage system independent).
        </p>

        <p>
        The following code fragment declares the transit protociol handler and 
        demonstrates the declaration of an alternative preferences backing store.  
        In effect we are telling the JVM to use a transient non-persistent storage system 
        while we conduct a test. Please keep in mind that this assignment is for test 
        purposes only as any modifications to preferences will not persist beyond the 
        life of the JVM (which is what we want during devopment and testing cycles).
        </p>

        <source>  System.setProperty( 
    "java.util.prefs.PreferencesFactory", 
    "net.dpml.transit.unit.LocalPreferencesFactory" );
  System.setProperty( "java.protocol.handler.pkgs", "net.dpml.transit" );</source>
        
        <p>
        Create a managed Transit instance using the 
        <code>net.dpml.transit.model.DefaultTransitModel()</code>.  Only one Transit 
        instance is alowed per JVM so this needs to happen before any other Transit 
        URL related operations occur.
        With the model establish we have complete control over the configuration
        of transit.  We can apply changes to the model now or after the Transit runtime
        as established as all changes to the model are propergated to the runtime by an 
        internal event model.  In addition, the model is remotable meaning that you can 
        publish the module in an RMI regstry or pass the model as an argument to a remote  
        management application.
        </p>

        <p>
        To commit the association of the model to the Transit runtime we neeed to 
        initialize transit using our model.  The following operation triggwers the 
        assignment of the transit model as the operative model to the transit singleton 
        instance.  Once committed the model cannot be reasigned for the life of the JVM.
        This provides assurance that the only appplication that is managing Transit is the 
        application that established the initial model.
        </p>

<source>  TransitModel model = new DefaultTransitModel();
  Transit.getInstance( model );</source>
        
      </subsection>
      
      <subsection name="Declaring a Dynamic ContentHandler">

        <p>
        With a reference to the TransitModel we can apply changes to partically every 
        aspect of the Transit system at runtime.  This includes the addition and removal of 
        remote host references, addition or removal of layout strategies, modification to 
        the cache system, and, addition, updating or removal of content handler plugins.
        The following code fragment demonstrates the construction and assignment of a new 
        content handler plugin into a running Transit system.
        </p>

        <source>
  URI uri = new URI( "artifact:plugin:dpml/metro/dpml-metro-central#3000" );
  model.getContentRegistryModel().addContentModel( "part", "Part Content Handler", uri );
        </source>

        <p>
        The above statement adds a new content handler for the artifact type 'part'.  The 
        handler is itself a plugin that extends Java's ContentHandler class.  Transit uses it's 
        own internal plugin machinery to load the content handler and use it to handle content 
        related requests for the 'part' artifact type.
        </p>

      </subsection>
      
      <subsection name="Using Content Handlers">

        <p>
        Content handlers are used when resolving getContent() requests on a URL or URLConnection.
        The following code demonstrates the aquisition of a reference to a Widget component based
        of a component defintion contained within a supplied part (which is itself a serialized 
        java object containing a full component deloyment strategy).
        </p>

        <source>
  URI uri = new URI( "artifact:part:acme/acme-widget#1234" );
  URL url = URI.toURL();
  Widget widget = (Widget) url.getContent();</source>

      </subsection>

    </section>

  </body>

</document>

